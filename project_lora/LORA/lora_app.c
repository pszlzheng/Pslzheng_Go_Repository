#include "lora_app.h"
#include "lora_ui.h"
#include "lora_cfg.h"
#include "usart3.h"
#include "string.h"
#include "led.h"
#include "delay.h"
#include "lcd.h"
#include "stdio.h"
#include "text.h"
#include "key.h"
#include "usart.h"
#include "ds18b20.h"
#include "pcf8574.h"
#include "adc.h"


//设备参数初始化(具体设备参数见lora_cfg.h定义)
_LoRa_CFG LoRa_CFG=
{
	.addr = LORA_ADDR,       //设备地址
	.power = LORA_POWER,     //发射功率
	.chn = LORA_CHN,         //信道
	.wlrate = LORA_RATE,     //空中速率
	.wltime = LORA_WLTIME,   //睡眠时间
	.mode = LORA_MODE,       //工作模式
	.mode_sta = LORA_STA,    //发送状态
	.bps = LORA_TTLBPS ,     //波特率设置
	.parity = LORA_TTLPAR    //校验位设置
};


GPIO_InitTypeDef GPIO_Initure;

//设备工作模式(用于记录设备状态)
u8 Lora_mode=0;// 0:配置模式 1:接收模式 2:发送模式

//记录中断状态
static u8 Int_mode=0;//0：关闭 1:上升沿 2:下降沿

//AUX中断设置，mode:配置的模式 0:关闭 1:上升沿 2:下降沿
void Aux_Int(u8 mode)
{
	if(!mode)
	{
		HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);//失能中断线11
	}
	else
	{
		if(mode==1)
		{
			 GPIO_Initure.Pin=GPIO_PIN_11; //PI11
       GPIO_Initure.Mode=GPIO_MODE_IT_RISING;//上升沿触发
		}
			
	  else if(mode==2)
		{
			 GPIO_Initure.Pin=GPIO_PIN_11; //PI11
       GPIO_Initure.Mode=GPIO_MODE_IT_FALLING;//下降沿触发
		}
		
		 HAL_GPIO_Init(GPIOI,&GPIO_Initure);//重新初始化
	   __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_11);//清除中断标志位
		 HAL_NVIC_SetPriority(EXTI15_10_IRQn,2,0); //抢占优先级为2，子优先级为0
		 HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);//使能
	}
	Int_mode = mode;//记录中断模式
}

void EXTI15_10_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_11);//调用中断处理公用函数	
}

////中断服务程序中需要做的事情
////在HAL库中所有的外部中断服务函数都会调用此函数
////GPIO_Pin:中断引脚号
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if(GPIO_Pin==GPIO_PIN_11)
	{
	   if(Int_mode==1)//上升沿(发送:开始发送数据 接收:数据开始输出)     
	   {
		  if(Lora_mode==1)//接收模式
		  {
			 USART3_RX_STA=0;//数据计数清0
		  }
		  Int_mode=2;//设置下降沿
		  LED0=0;//DS0亮
	   }
       else if(Int_mode==2)//下降沿(发送:数据已发送完 接收:数据输出结束)	
	   {
		  if(Lora_mode==1)//接收模式
		  {
			 USART3_RX_STA|=1<<15;//数据计数标记完成
		  }else if(Lora_mode==2)//发送模式(串口数据发送完毕)
		  {
			 Lora_mode=1;//进入接收模式
		  }
		  Int_mode=1;//设置上升沿
          LED0=1;//DS0灭		   
	   }
     Aux_Int(Int_mode);//重新设置中断边沿
	}
}

//LoRa模块初始化
//返回值:0,检测成功
//       1,检测失败
u8 LoRa_Init(void)
{
	u8 retry=0;
	u8 temp=1;

	__HAL_RCC_GPIOA_CLK_ENABLE();          //开启GPIOA时钟
	__HAL_RCC_GPIOI_CLK_ENABLE();          //开启GPIOI时钟
	 
	GPIO_Initure.Pin=GPIO_PIN_4;           //PA4
	GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP; //推挽输出
	GPIO_Initure.Pull=GPIO_PULLDOWN;       //下拉
	GPIO_Initure.Speed=GPIO_SPEED_HIGH;    //高速
	HAL_GPIO_Init(GPIOA,&GPIO_Initure);

	GPIO_Initure.Pin=GPIO_PIN_11;          //PI11
	GPIO_Initure.Mode=GPIO_MODE_IT_RISING; //上升沿触发
	GPIO_Initure.Pull=GPIO_PULLDOWN;       //下拉
	GPIO_Initure.Speed=GPIO_SPEED_HIGH;    //高速
	HAL_GPIO_Init(GPIOI,&GPIO_Initure);
	
	LORA_MD0=0;				//MD0,AUX都为0时，lora进入一般模式，进行透传
	LORA_AUX=0;
	
	while(LORA_AUX)//确保LORA模块在空闲状态下(LORA_AUX=0)
	{
		 Show_Str(40+30,50+20,200,16,"BUSYING NOW!!!",16,0); 	
		 delay_ms(500);
		 Show_Str(40+30,50+20,200,16,"______________",16,0);
     delay_ms(100);		 
	}
	usart3_init(115200);//初始化串口3
	LORA_MD0=1;//进入AT（配置）模式
	delay_ms(40);
	retry=3;
	while(retry--)
	{
	 if(!lora_send_cmd("AT","OK",70))
	 {
		 temp=0;//检测成功
		 break;
	 }	
	}
	if(retry==0) temp=1;//检测失败
	return temp;
}

//Lora模块参数配置
void LoRa_Set(void)
{
	u8 sendbuf[20];
	u8 lora_addrh,lora_addrl=0;
	
	usart3_set(LORA_TTLBPS_115200,LORA_TTLPAR_8N1);//进入配置模式前设置通信波特率和校验位(115200 8位数据 1位停止 无数据校验）
	usart3_rx(1);//开启串口3接收
	
	while(LORA_AUX);//等待模块空闲
	LORA_MD0=1; 		//进入配置模式
	delay_ms(40);
	Lora_mode=0;//标记"配置模式"
	
	lora_addrh = (LoRa_CFG.addr>>8)&0xff;//通信地址的高八位
	lora_addrl = LoRa_CFG.addr&0xff;//通信地址低八位
	sprintf((char*)sendbuf,"AT+ADDR=%02x,%02x",lora_addrh,lora_addrl);//设置设备地址
	lora_send_cmd(sendbuf,"OK",50);
	sprintf((char*)sendbuf,"AT+WLRATE=%d,%d",LoRa_CFG.chn,LoRa_CFG.wlrate);//设置信道和空中速率
	lora_send_cmd(sendbuf,"OK",50);
	sprintf((char*)sendbuf,"AT+TPOWER=%d",LoRa_CFG.power);//设置发射功率
	lora_send_cmd(sendbuf,"OK",50);
	sprintf((char*)sendbuf,"AT+CWMODE=%d",LoRa_CFG.mode);//设置工作模式
	lora_send_cmd(sendbuf,"OK",50);
	sprintf((char*)sendbuf,"AT+TMODE=%d",LoRa_CFG.mode_sta);//设置发送状态
	lora_send_cmd(sendbuf,"OK",50);
	sprintf((char*)sendbuf,"AT+WLTIME=%d",LoRa_CFG.wltime);//设置睡眠时间
	lora_send_cmd(sendbuf,"OK",50);
	sprintf((char*)sendbuf,"AT+UART=%d,%d",LoRa_CFG.bps,LoRa_CFG.parity);//设置串口波特率、数据校验位
	lora_send_cmd(sendbuf,"OK",50);

	LORA_MD0=0;//退出配置,进入通信
	delay_ms(40);
	while(LORA_AUX);//判断是否空闲(模块会重新配置参数)
	USART3_RX_STA=0;
	Lora_mode=1;//标记"接收模式"
	usart3_set(LoRa_CFG.bps,LoRa_CFG.parity);//返回通信,更新通信串口配置(波特率、数据校验位)
	Aux_Int(1);//设置LORA_AUX上升沿中断
}

float data[18]={18,6.8,6.0,22,6.9,6.0,26,7.0,6.0,20,7.2,8.0,24,7.3,8.0,27,7.4,8.0};
char flag='Y';

void ST_MON_1(char check,float tm1,float ph1,float oxy1)//第一阶段的一号水产品（1月龄）
{
	float ph;
	float oxy;
	float temp;
	if (check=='1')
	
	{
		data[0]=tm1;
		data[1]=ph1;
		data[2]=oxy1;
	}
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	oxy=Get_Adc_Average(ADC_CHANNEL_5,10)*0.0032;
	ph=Get_Adc_Average(ADC_CHANNEL_6,10)*0.0024;
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	if((temp/10)>data[0]-2 && (temp/10)<=data[0]+2)		LED_TEMP=0;
	else
	{
		LED_TEMP=1;
		flag='N';
	}
	if(ph>data[1]-0.8 && ph<data[1]+0.8)	LED_PH=0;
	else
	{
		LED_PH=1;
		flag='N';
	}
	if(oxy>data[2]-2)	LED_OXY=0;
	else
	{
		LED_OXY=1;
		FUN_Oxyg=0;
		flag='N';
	}
}

void ND_MON_1(char check,float tm1,float ph1,float oxy1)//第二阶段的一号水产品（3月龄）
{
	float ph;
	float oxy;
	float temp;
	if (check=='1')
	{
		data[3]=tm1;
		data[4]=ph1;
		data[5]=oxy1;
	}
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	oxy=Get_Adc_Average(ADC_CHANNEL_5,10)*0.0032;
	ph=Get_Adc_Average(ADC_CHANNEL_6,10)*0.0024;
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	if((temp/10)>data[3]-2 && (temp/10)<=data[3]+2)		LED_TEMP=0;
	else
	{
		LED_TEMP=1;
		flag='N';
	}
	if(ph>data[4]-0.8 && ph<data[4]+0.8)	LED_PH=0;
	else
	{
		LED_PH=1;
		flag='N';
	}
	if(oxy>data[5]-3)
	{
		LED_OXY=0;
		FUN_Oxyg=1;
	}
	else
	{
		LED_OXY=1;
		FUN_Oxyg=0;
		flag='N';
	}
}

void RD_MON_1(char check,float tm1,float ph1,float oxy1)//第三阶段的一号水产品（7月龄）
{
	float ph;
	float oxy;
	float temp;
	if (check=='1')
	{
		data[6]=tm1;
		data[7]=ph1;
		data[8]=oxy1;
	}
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	oxy=Get_Adc_Average(ADC_CHANNEL_5,10)*0.0032;
	ph=Get_Adc_Average(ADC_CHANNEL_6,10)*0.0024;
	if((temp/10)>data[6]-2 && (temp/10)<=data[6]+2)		LED_TEMP=0;
	else
	{
		LED_TEMP=1;
		flag='N';
	}
	if(ph>data[7]-0.8 && ph<data[7]+0.8)	LED_PH=0;
	else
	{
		LED_PH=1;
		flag='N';
	}
	if(oxy>data[8]-4)	LED_OXY=0;
	else
	{
		LED_OXY=1;
		FUN_Oxyg=0;
		flag='N';
	}
}

void ST_MON_2(char check,float tm1,float ph1,float oxy1)//第一阶段的二号水产品（1月龄）
{
	float ph;
	float oxy;
	float temp;
	if (check=='1')
	{
		data[6]=tm1;
		data[7]=ph1;
		data[8]=oxy1;
	}
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	oxy=Get_Adc_Average(ADC_CHANNEL_5,10)*0.0032;
	ph=Get_Adc_Average(ADC_CHANNEL_6,10)*0.0024;
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	if((temp/10)>data[9]-2 && (temp/10)<=data[9]+2)		LED_TEMP=0;
	else
	{
		LED_TEMP=1;
		flag='N';
	}
	if(ph>data[10]-0.8 && ph<data[10]+0.8)	LED_PH=0;
	else
	{
		LED_PH=1;
		flag='N';
	}
	if(oxy>data[11]-4)	LED_OXY=0;
	else
	{
		LED_OXY=1;
		FUN_Oxyg=0;
		flag='N';
	}
}

void ND_MON_2(char check,float tm1,float ph1,float oxy1)//第二阶段的二号水产品（3月龄）
{
	float ph;
	float oxy;
	float temp;
	if (check=='1')
	{
		data[12]=tm1;
		data[13]=ph1;
		data[14]=oxy1;
	}
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	oxy=Get_Adc_Average(ADC_CHANNEL_5,10)*0.0032;
	ph=Get_Adc_Average(ADC_CHANNEL_6,10)*0.0024;
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	if((temp/10)>data[12]-2 && (temp/10)<=data[12]+2)		LED_TEMP=0;
	else
	{
		LED_TEMP=1;
		flag='N';
	}
	if(ph>data[13]-0.8 && ph<data[7]+0.8)	LED_PH=0;
	else
	{
		LED_PH=1;
		flag='N';
	}
	if(oxy>data[14]-3)	LED_OXY=0;
	else
	{
		LED_OXY=1;
		FUN_Oxyg=0;
		flag='N';
	}
}

void RD_MON_2(char check,float tm1,float ph1,float oxy1)//第三阶段的二号水产品（7月龄）
{
	float ph;
	float oxy;
	float temp;
	if (check=='1')
	{
		data[15]=tm1;
		data[16]=ph1;
		data[17]=oxy1;
	}
	PCF8574_ReadBit(BEEP_IO);
	temp=DS18B20_Get_Temp();
	oxy=Get_Adc_Average(ADC_CHANNEL_5,10)*0.0032;
	ph=Get_Adc_Average(ADC_CHANNEL_6,10)*0.0024;
	if((temp/10)>data[15]-2 && (temp/10)<=data[15]+2)		LED_TEMP=0;
	else
	{
		LED_TEMP=1;
		flag='N';
	}
	if(ph>data[16]-0.8 && ph<data[16]+0.8)	LED_PH=0;
	else
	{
		LED_PH=1;
		flag='N';
	}
	if(oxy>data[17]-4)	LED_OXY=0;
	else
	{
		LED_OXY=1;
		FUN_Oxyg=0;
		flag='N';
	}
}

void Function(void)//每隔一段时间自动投喂食物，施罚（或者消毒剂），增氧
{
	FUN_Fert=0;
	FUN_Food=0;
	delay_ms(5000);
	FUN_Food=1;
	FUN_Fert=1;
}

u8 Dire_Date[]={0x11,0x22,0x33,0x44,0x55};//定向传输数据
u8 date[30]={0};//定向数组
u8 Tran_Data[30]={0};//透传数组

#define Dire_DateLen sizeof(Dire_Date)/sizeof(Dire_Date[0])
extern u32 obj_addr;//记录用户输入目标地址
extern u8 obj_chn;//记录用户输入目标信道

u8 wlcd_buff[10]={0}; //LCD显示字符串缓冲区

void LoRa_SendData(int counter)//Lora模块发送数据
{      
	float temperature=20;
	float ph=7.5;
	float oxy=5.2;
  u16 addr;
	u16 adcx;
	u16 adcy;
	u8 chn;
	u16 i=0;
	PCF8574_ReadBit(BEEP_IO);
	if(LoRa_CFG.mode_sta == LORA_STA_Tran)//透明传输
	{
		temperature=DS18B20_Get_Temp();
		adcx=Get_Adc_Average(ADC_CHANNEL_5,10);//获取通道5的20次取平均溶氧量转换值
		adcy=Get_Adc_Average(ADC_CHANNEL_6,10);//获取通道6的20次取平均酸碱度转换值
		oxy=adcx*0.012;
		ph=adcy*0.0050;
		sprintf((char*)Tran_Data,"%s-%.2f-%.2f-%.2f-%s-%d","STM_TWO",ph,temperature/10,oxy,"1",counter);
		u3_printf("%s",Tran_Data);
		LCD_Fill(0,195,240,220,WHITE);//清除显示
		Show_Str_Mid(10,195,Tran_Data,16,240);
	}
	else if(LoRa_CFG.mode_sta == LORA_STA_Dire)//定向传输
	{
		addr = (u16)obj_addr;//目标地址
		chn = obj_chn;//目标信道
		date[i++] =(addr>>8)&0xff;//高位地址
		date[i++] = addr&0xff;//低位地址
		date[i] = chn;  //无线信道
		for(i=0;i<Dire_DateLen;i++)//数据写到发送BUFF
		{
			date[3+i] = Dire_Date[i];
		}
		for(i=0;i<(Dire_DateLen+3);i++)
		{
			while(__HAL_UART_GET_FLAG(&UART3_Handler,UART_FLAG_TXE)== RESET);//循环发送,直到发送完毕   
			HAL_UART_Transmit(&UART3_Handler,&date[i],1,1000);	
		}	
    //将十六进制的数据转化为字符串打印在lcd_buff数组
		sprintf((char*)wlcd_buff,"%x %x %x %x %x %x %x %x",
		date[0],date[1],date[2],date[3],date[4],date[5],date[6],date[7]);	
		LCD_Fill(0,200,240,230,WHITE);//清除显示
		Show_Str_Mid(10,200,wlcd_buff,16,240);//显示发送的数据		
	  Dire_Date[4]++;//Dire_Date[4]数据更新	
	}
}

u8 rlcd_buff[10]={0}; //LCD显示字符串缓冲区

void LoRa_ReceData(void)//Lora模块接收数据
{
	u16 i=0;
	u16 len=0;
	//有数据来了
	if(USART3_RX_STA&0x8000)
	{
		len = USART3_RX_STA&0X7FFF;
		USART3_RX_BUF[len]=0;//添加结束符
		USART3_RX_STA=0;

		for(i=0;i<len;i++)
		{
			while(__HAL_UART_GET_FLAG(&UART1_Handler,UART_FLAG_TXE)== RESET);//循环发送,直到发送完毕   
			HAL_UART_Transmit(&UART1_Handler,&USART3_RX_BUF[i],1,1000);	
		}
		LCD_Fill(10,260,240,320,WHITE);
		if(LoRa_CFG.mode_sta==LORA_STA_Tran)//透明传输
		{
			if (USART3_RX_BUF[6]=='1')
			{
				Show_Str_Mid(10,270,USART3_RX_BUF,16,240);//显示接收到的数据
				Lora_analyze(USART3_RX_BUF);
			}
		}
		else if(LoRa_CFG.mode_sta==LORA_STA_Dire)//定向传输
		{
			//将十六进制的数据转化为字符串打印在lcd_buff数组
			sprintf((char*)rlcd_buff,"%x %x %x %x %x",USART3_RX_BUF[0],USART3_RX_BUF[1],USART3_RX_BUF[2],USART3_RX_BUF[3],USART3_RX_BUF[4]);
			Show_Str_Mid(10,270,rlcd_buff,16,240);//显示接收到的数据
			delay_ms(1000);
			Lora_analyze(rlcd_buff);
		}
		memset((char*)USART3_RX_BUF,0x00,len);//串口接收缓冲区清0
	}
}


/*
逻辑如下：
首先第一位数字表示当前需要养殖的物种名称，第二位表示该物种所处阶段，第三位表示是否更新水体指标，
剩余三位分别表示新的适宜PH，新的适宜溶氧量，新的适宜水体温度，后三位当且仅当第三位为’1‘时有效
*/
void Lora_analyze(u8* table)
{
	table[3]=table[3]-48;
	table[4]=table[4]-48;
	table[5]=table[5]-48;
	switch(table[0])
	{
		case '0':
			if(table[1]=='0')
			{
				Show_Str_Mid(10,290,"1月龄 罗非鱼",16,240);
				ST_MON_1(table[2],table[3],table[4],table[5]);
			}
			else if(table[1]=='1')
			{
				Show_Str_Mid(10,290,"3月龄 罗非鱼",16,240);
				ND_MON_1(table[2],table[3],table[4],table[5]);
			}
			else if(table[1]=='2')
			{
				Show_Str_Mid(10,290,"7月龄 罗非鱼",16,240);
				RD_MON_1(table[2],table[3],table[4],table[5]);
			}
			break;
		case '1':
			if(table[1]=='0')
			{
				Show_Str_Mid(10,290,"1月龄 青鱼",16,240);
				ST_MON_2(table[2],table[3],table[4],table[5]);
			}
			else if(table[1]=='1')
			{
				Show_Str_Mid(10,290,"3月龄 青鱼",16,240);
				ND_MON_2(table[2],table[3],table[4],table[5]);
			}
			else if(table[1]=='2')
			{
				Show_Str_Mid(10,290,"7月龄 青鱼",16,240);
				RD_MON_2(table[2],table[3],table[4],table[5]);
			}
			break;
		default:
			Show_Str_Mid(10,300,"指令错误！！！",18,100);
			break;
	}
}

//发送和接收处理
void LoRa_Process(void)
{
	u8 key=0;
	u8 t=0;
	int counter=1;
	short num=0;
	DATA:
	Process_ui();//界面显示
	LoRa_Set();//LoRa配置(进入配置需设置串口波特率为115200,) 
	while(1)
	{
		key = KEY_Scan(0);
		if(key==KEY0_PRES)
		{
			if(LoRa_CFG.mode_sta==LORA_STA_Dire)//若是定向传输,则进入配置目标地址和信道界面
			{
				usart3_rx(0);//关闭串口接收
				Aux_Int(0);//关闭中断
				Dire_Set();//进入设置目标地址和信道
				goto DATA;
			}
		}
		else if(key==WKUP_PRES)//返回主菜单页面
		{
			LORA_MD0=1; //进入配置模式
	    delay_ms(40);
			usart3_rx(0);//关闭串口接收
			Aux_Int(0);//关闭中断
			break;
		}
		else if(key==KEY1_PRES)//发送数据
		{
			if(!LORA_AUX&&(LoRa_CFG.mode!=LORA_MODE_SLEEP))//空闲且非省电模式
			{
				while(1)
				{
					LoRa_ReceData();
					while(num<10)
					{
						Lora_mode=2;//标记"发送状态"
						LoRa_SendData(counter);//发送数据
						delay_ms(1000);
						counter+=1;
						num+=1;
					}
					num=0;
				}
			}
		}
		t++;
		if(t==20)
		{
			t=0;
			LED1=~LED1;
		}
		delay_ms(10);
  }
}


//主测试函数
void Lora_Test(void)
{
	u8 t=0;
	u8 key=0;
	u8 netpro=0;
	LCD_Clear(WHITE);
	POINT_COLOR=RED;
	Show_Str_Mid(0,30,"SMART FISH POOL SYSTEM",16,240); 
	while(LoRa_Init())//初始化ATK-LORA-01模块
	{
		Show_Str(40+30,50+20,200,16,"NO DEVICE DETECTED!!!",16,0); 	
		delay_ms(300);
		Show_Str(40+30,50+20,200,16,"BLANK",16,0);
	}
	Show_Str(40+30,50+20,200,16,"DEVICE DETECTED!!!",16,0);
  delay_ms(500); 	
	Menu_ui();//菜单
	while(1)
	{
		key = KEY_Scan(0);
		if(key)
		{
			Show_Str(30+10,95+45+netpro*25,200,16,"  ",16,0);//清空之前的显示
			if(key==KEY0_PRES)//KEY0按下
			{
				if(netpro<6)netpro++;
				else netpro=0;
			}
			else if(key==KEY1_PRES)//KEY1按下
			{
				if(netpro>0)netpro--;
				else netpro=6; 
			}
			else if(key==WKUP_PRES)//KEY_UP按下
			{
				if(netpro==0)//进入通信选项
				{
				  LoRa_Process();//开始数据测试
				  netpro=0;//索引返回第0
				  Menu_ui();
				}
				else
				{
					Show_Str(30+40,95+45+netpro*25+2,200,16,"________",16,1);//显示下划线,表示选中
					Show_Str(30+10,95+45+netpro*25,200,16,"-->",16,0);//指向新条目
					Menu_cfg(netpro);//参数配置
					LCD_Fill(30+40,95+45+netpro*25+2+15,30+40+100,95+45+netpro*25+2+18,WHITE);//清除下划线显示
				}
			}
			Show_Str(30+10,95+45+netpro*25,200,16,"-->",16,0);//指向新条目
		}
		t++;
		if(t==30)
		{
			t=0;
			LED1=~LED1;
		}
		delay_ms(10);
	}	
}
